<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TouchDesigner Style: Webcam + Perlin3D + Color Blend</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; }
    canvas    { width:100%; height:100%; display:block; }
    #controls {
      position: absolute;
      top:10px; left:10px;
      color:#fff; font-family:sans-serif;
      user-select: none;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      min-width: 200px;
    }
    #controls label {
      display: block;
      margin: 8px 0;
      font-size: 12px;
    }
    #controls input[type="range"] {
      width: 150px;
      margin-left: 10px;
    }
    #controls input[type="checkbox"] {
      margin-right: 8px;
    }
    .control-group {
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
      margin-bottom: 10px;
    }
    .control-group:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    .group-title {
      font-weight: bold;
      color: #ccc;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>

  <!-- hidden video source -->
  <video id="cam" playsinline muted style="display:none;"></video>
  <!-- color lookup image -->
  <img id="colorLookup" style="display:none;" crossorigin="anonymous">
  <!-- our GL surface -->
  <canvas id="gl"></canvas>

  <!-- TouchDesigner-style controls -->
  <div id="controls">
    <div class="group-title">TouchDesigner Style Controls</div>
    
    <div class="control-group">
      <div class="group-title">Noise Parameters</div>
      <label>Seed: <span id="seedVal">1348</span>
        <input type="range" id="seed" min="0" max="9999" step="1" value="1348">
      </label>
      <label>Period: <span id="periodVal">0.05</span>
        <input type="range" id="period" min="0.01" max="2.0" step="0.01" value="0.05">
      </label>
      <label>Harmonics: <span id="harmonicsVal">4</span>
        <input type="range" id="harmonics" min="0" max="8" step="1" value="4">
      </label>
      <label>Harmonic Spread: <span id="spreadVal">2.0</span>
        <input type="range" id="spread" min="1.0" max="4.0" step="0.1" value="2.0">
      </label>
      <label>Harmonic Gain: <span id="gainVal">0.5</span>
        <input type="range" id="gain" min="0.0" max="1.0" step="0.01" value="0.5">
      </label>
      <label>Roughness: <span id="roughnessVal">0.0</span>
        <input type="range" id="roughness" min="0.0" max="1.0" step="0.01" value="0.0">
      </label>
      <label>Exponent: <span id="exponentVal">1.0</span>
        <input type="range" id="exponent" min="0.1" max="3.0" step="0.01" value="1.0">
      </label>
      <label>Amplitude: <span id="amplitudeVal">1.0</span>
        <input type="range" id="amplitude" min="0.0" max="2.0" step="0.01" value="1.0">
      </label>
      <label>Offset: <span id="offsetVal">0.0</span>
        <input type="range" id="offset" min="0.0" max="1.0" step="0.01" value="0.0">
      </label>
    </div>
    
    <div class="control-group">
      <div class="group-title">Animation</div>
      <label>Speed: <span id="speedVal">1.0</span>
        <input type="range" id="speed" min="0.0" max="3.0" step="0.1" value="1.0">
      </label>
      <label><input type="checkbox" id="monochrome"> Monochrome</label>
    </div>
    
    <div class="control-group">
      <div class="group-title">Blend</div>
      <label>Intensity: <span id="intensityVal">1.0</span>
        <input type="range" id="intensity" min="0.0" max="2.0" step="0.01" value="1.0">
      </label>
      <label>Video Influence: <span id="videoInfluenceVal">0.3</span>
        <input type="range" id="videoInfluence" min="0.0" max="1.0" step="0.01" value="0.3">
      </label>
      <label>Color Saturation: <span id="colorSaturationVal">0.8</span>
        <input type="range" id="colorSaturation" min="0.0" max="2.0" step="0.01" value="0.8">
      </label>
      <label>Hue Shift: <span id="hueShiftVal">0.6</span>
        <input type="range" id="hueShift" min="0.0" max="1.0" step="0.01" value="0.6">
      </label>
      <label>Color Mode: 
        <select id="colorMode">
          <option value="0">Default Perlin</option>
          <option value="1">Enhanced HSL</option>
          <option value="2" selected>Image Lookup</option>
        </select>
      </label>
      <label>Upload Color Image: 
        <input type="file" id="colorImageUpload" accept="image/*">
      </label>
      <label>Blur Amount: <span id="blurAmountVal">0.0</span>
        <input type="range" id="blurAmount" min="0.0" max="10.0" step="0.1" value="0.0">
      </label>
      <label>Mode: 
        <select id="blendMode">
          <option value="0">Multiply</option>
          <option value="1">Add</option>
          <option value="2">Subtract</option>
          <option value="3" selected>Color</option>
        </select>
      </label>
    </div>
  </div>

  <script type="module">
  // ———————————— Boilerplate & getUserMedia ————————————
  const video  = document.getElementById('cam');
  const canvas = document.getElementById('gl');
  const gl     = canvas.getContext('webgl2', {premultipliedAlpha:false});
  if(!gl) throw new Error("WebGL2 required");

  // resize canvas to fill
  function resize(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    if(canvas.width!==w || canvas.height!==h){
      canvas.width=w; canvas.height=h;
      gl.viewport(0,0,w,h);
    }
  }
  window.addEventListener('resize', resize);
  resize();

  // ask camera
  navigator.mediaDevices.getUserMedia({video:{width:640,height:480}})
    .then(s => { video.srcObject = s; return video.play() })
    .then(init)
    .catch(e=> alert("Camera error: "+e.message))

  // ———————————— init GL ————————————
  function init(){
    // compile shaders + link
    const prog = createProgram(gl, vertexSrc, fragmentSrc);
    gl.useProgram(prog);

    // full-screen triangle
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    const posBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    // 3 verts cover entire screen
    gl.bufferData(gl.ARRAY_BUFFER,
      new Float32Array([ -1,-1,  3,-1,  -1,3 ]),
      gl.STATIC_DRAW
    );
    const aPos = gl.getAttribLocation(prog,'aPosition');
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

    // single video texture
    const videoTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, videoTex);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);

    // color lookup texture
    const colorTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, colorTex);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT);

    // Load default color lookup image
    const colorLookupImg = document.getElementById('colorLookup');
    
    // Create a default psychedelic color pattern
    function createDefaultColorPattern() {
      const canvas = document.createElement('canvas');
      canvas.width = 500;
      canvas.height = 500;
      const ctx = canvas.getContext('2d');
      
      // Create concentric circles with rainbow colors
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const maxRadius = Math.min(centerX, centerY);
      
      for (let r = maxRadius; r > 0; r -= 2) {
        const hue = (r / maxRadius) * 360 + (r * 2) % 360;
        const saturation = 80 + (r % 20);
        const lightness = 50 + (r % 30);
        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        ctx.fill();
      }
      
      colorLookupImg.src = canvas.toDataURL();
    }
    
    function loadColorTexture() {
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, colorTex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, colorLookupImg);
    }
    
    // Create and load default pattern
    createDefaultColorPattern();
    colorLookupImg.onload = loadColorTexture;

    // uniform locations
    const uni = {
      uVideo:        gl.getUniformLocation(prog,'uVideo'),
      uColorLookup:  gl.getUniformLocation(prog,'uColorLookup'),
      uTime:         gl.getUniformLocation(prog,'uTime'),
      uSeed:         gl.getUniformLocation(prog,'uSeed'),
      uPeriod:       gl.getUniformLocation(prog,'uPeriod'),
      uHarmonics:    gl.getUniformLocation(prog,'uHarmonics'),
      uSpread:       gl.getUniformLocation(prog,'uSpread'),
      uGain:         gl.getUniformLocation(prog,'uGain'),
      uRoughness:    gl.getUniformLocation(prog,'uRoughness'),
      uExponent:     gl.getUniformLocation(prog,'uExponent'),
      uAmplitude:    gl.getUniformLocation(prog,'uAmplitude'),
      uOffset:       gl.getUniformLocation(prog,'uOffset'),
      uMonochrome:   gl.getUniformLocation(prog,'uMonochrome'),
      uSpeed:        gl.getUniformLocation(prog,'uSpeed'),
      uIntensity:    gl.getUniformLocation(prog,'uIntensity'),
      uBlendMode:    gl.getUniformLocation(prog,'uBlendMode'),
      uVideoInfluence: gl.getUniformLocation(prog,'uVideoInfluence'),
      uColorSaturation: gl.getUniformLocation(prog,'uColorSaturation'),
      uHueShift:     gl.getUniformLocation(prog,'uHueShift'),
      uColorMode:    gl.getUniformLocation(prog,'uColorMode'),
      uBlurAmount:   gl.getUniformLocation(prog,'uBlurAmount'),
    };

    // bind our samplers to texture units
    gl.uniform1i(uni.uVideo, 0);
    gl.uniform1i(uni.uColorLookup, 1);

    // UI controls
    const controls = {
      seed: document.getElementById('seed'),
      period: document.getElementById('period'),
      harmonics: document.getElementById('harmonics'),
      spread: document.getElementById('spread'),
      gain: document.getElementById('gain'),
      roughness: document.getElementById('roughness'),
      exponent: document.getElementById('exponent'),
      amplitude: document.getElementById('amplitude'),
      offset: document.getElementById('offset'),
      speed: document.getElementById('speed'),
      monochrome: document.getElementById('monochrome'),
      intensity: document.getElementById('intensity'),
      blendMode: document.getElementById('blendMode'),
      videoInfluence: document.getElementById('videoInfluence'),
      colorSaturation: document.getElementById('colorSaturation'),
      hueShift: document.getElementById('hueShift'),
      colorMode: document.getElementById('colorMode'),
      blurAmount: document.getElementById('blurAmount'),
    };

    // Value display elements
    const displays = {
      seed: document.getElementById('seedVal'),
      period: document.getElementById('periodVal'),
      harmonics: document.getElementById('harmonicsVal'),
      spread: document.getElementById('spreadVal'),
      gain: document.getElementById('gainVal'),
      roughness: document.getElementById('roughnessVal'),
      exponent: document.getElementById('exponentVal'),
      amplitude: document.getElementById('amplitudeVal'),
      offset: document.getElementById('offsetVal'),
      speed: document.getElementById('speedVal'),
      intensity: document.getElementById('intensityVal'),
      videoInfluence: document.getElementById('videoInfluenceVal'),
      colorSaturation: document.getElementById('colorSaturationVal'),
      hueShift: document.getElementById('hueShiftVal'),
      blurAmount: document.getElementById('blurAmountVal'),
    };

    // Update display values
    function updateDisplays() {
      Object.keys(displays).forEach(key => {
        if(controls[key] && displays[key]) {
          displays[key].textContent = controls[key].value;
        }
      });
    }

    // Add event listeners
    Object.keys(controls).forEach(key => {
      if(controls[key]) {
        controls[key].addEventListener('input', updateDisplays);
      }
    });

    // File upload handler
    const fileUpload = document.getElementById('colorImageUpload');
    fileUpload.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
          colorLookupImg.src = event.target.result;
          colorLookupImg.onload = loadColorTexture;
        };
        reader.readAsDataURL(file);
      }
    });

    // animation loop
    const t0 = performance.now();
    function draw(){
      resize();
      gl.clear(gl.COLOR_BUFFER_BIT);

      // upload current camera frame
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, videoTex);
      gl.texImage2D(
        gl.TEXTURE_2D,0,gl.RGB,gl.RGB,gl.UNSIGNED_BYTE,video
      );

      // update uniforms from controls
      const t = (performance.now() - t0) * 0.001 * parseFloat(controls.speed.value);
      gl.uniform1f(uni.uTime, t);
      gl.uniform1f(uni.uSeed, parseFloat(controls.seed.value));
      gl.uniform1f(uni.uPeriod, parseFloat(controls.period.value));
      gl.uniform1i(uni.uHarmonics, parseInt(controls.harmonics.value));
      gl.uniform1f(uni.uSpread, parseFloat(controls.spread.value));
      gl.uniform1f(uni.uGain, parseFloat(controls.gain.value));
      gl.uniform1f(uni.uRoughness, parseFloat(controls.roughness.value));
      gl.uniform1f(uni.uExponent, parseFloat(controls.exponent.value));
      gl.uniform1f(uni.uAmplitude, parseFloat(controls.amplitude.value));
      gl.uniform1f(uni.uOffset, parseFloat(controls.offset.value));
      gl.uniform1i(uni.uMonochrome, controls.monochrome.checked ? 1 : 0);
      gl.uniform1f(uni.uIntensity, parseFloat(controls.intensity.value));
      gl.uniform1i(uni.uBlendMode, parseInt(controls.blendMode.value));
      gl.uniform1f(uni.uVideoInfluence, parseFloat(controls.videoInfluence.value));
      gl.uniform1f(uni.uColorSaturation, parseFloat(controls.colorSaturation.value));
      gl.uniform1f(uni.uHueShift, parseFloat(controls.hueShift.value));
      gl.uniform1i(uni.uColorMode, parseInt(controls.colorMode.value));
      gl.uniform1f(uni.uBlurAmount, parseFloat(controls.blurAmount.value));

      // draw that single triangle
      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  }

  // ———————————— GLSL sources ————————————
  const vertexSrc = `#version 300 es
  in vec2 aPosition;
  out vec2 vUV;
  void main(){
    vUV = aPosition * 0.5 + 0.5;
    vUV.y = 1.0 - vUV.y;  // Flip Y coordinate to fix upside-down video
    gl_Position = vec4(aPosition,0.,1.);
  }`;

  const fragmentSrc = `#version 300 es
  precision highp float;
  in vec2 vUV;
  out vec4 fragColor;

  uniform sampler2D uVideo;
  uniform sampler2D uColorLookup;
  uniform float uTime;
  uniform float uSeed;
  uniform float uPeriod;
  uniform int   uHarmonics;
  uniform float uSpread;
  uniform float uGain;
  uniform float uRoughness;
  uniform float uExponent;
  uniform float uAmplitude;
  uniform float uOffset;
  uniform int   uMonochrome;
  uniform float uSpeed;
  uniform float uIntensity;
  uniform int   uBlendMode;  // 0=Multiply, 1=Add, 2=Subtract, 3=Color
  uniform float uVideoInfluence;
  uniform float uColorSaturation;
  uniform float uHueShift;
  uniform int   uColorMode;
  uniform float uBlurAmount;

  // ————— 3D Simplex (Ashima) + fbm —————
  vec3 mod289(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }
  vec4 mod289(vec4 x){ return x - floor(x*(1.0/289.0))*289.0; }
  vec4 permute(vec4 x){ return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314*r; }

  float snoise(vec3 v){
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0,0.5,1.0,2.0);
    vec3 i = floor(v + dot(v,C.yyy));
    vec3 x0= v - i + dot(i,C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1= min(g.xyz,l.zxy), i2= max(g.xyz,l.zxy);
    vec3 x1= x0 - i1 + C.xxx;
    vec3 x2= x0 - i2 + C.yyy;
    vec3 x3= x0 - D.yyy;
    i = mod289(i);
    vec4 p = permute( permute( permute(
      i.z + vec4(0.0,i1.z,i2.z,1.0))
      + i.y + vec4(0.0,i1.y,i2.y,1.0))
      + i.x + vec4(0.0,i1.x,i2.x,1.0));
    vec4 j = p - 49.0*floor(p*(1.0/49.0));
    vec4 x_ = floor(j*(1.0/7.0));
    vec4 y_ = floor(j - 7.0*x_);
    vec4 x = x_*(1.0/7.0) + (1.0/14.0);
    vec4 y = y_*(1.0/7.0) + (1.0/14.0);
    vec4 h = 1.0 - abs(x)-abs(y);
    vec4 b0 = vec4(x.xy,y.xy), b1 = vec4(x.zw,y.zw);
    vec4 s0 = floor(b0)*2.0+1.0, s1 = floor(b1)*2.0+1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0=vec3(a0.xy,h.x), p1=vec3(a0.zw,h.y),
         p2=vec3(a1.xy,h.z), p3=vec3(a1.zw,h.w);
    vec4 norm = taylorInvSqrt(vec4(
      dot(p0,p0), dot(p1,p1),
      dot(p2,p2), dot(p3,p3)));
    p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
    vec4 m = max(0.6 - vec4(
      dot(x0,x0), dot(x1,x1),
      dot(x2,x2), dot(x3,x3)), 0.0);
    m = m*m;
    return 42.0 * dot(m*m, vec4(
      dot(p0,x0), dot(p1,x1),
      dot(p2,x2), dot(p3,x3)));
  }

  float fbm(vec3 p){
    // Add seed offset
    p += vec3(uSeed * 0.001);
    
    float f = 0.0;
    float amp = 1.0;
    float maxValue = 0.0;
    
    for(int i = 0; i < 8; i++){
      if(i >= uHarmonics) break;
      
      float n = snoise(p);
      
      // Apply roughness (affects how each octave contributes)
      float roughAmp = amp * (1.0 - uRoughness * float(i) / 8.0);
      
      f += roughAmp * n;
      maxValue += roughAmp;
      
      p *= uSpread;
      amp *= uGain;
    }
    
    // Normalize by max possible value
    if(maxValue > 0.0) {
      f /= maxValue;
    }
    
    return f;
  }

  // ————— Enhanced HSL helpers for better color mapping —————
  vec3 rgb2hsl(vec3 c){
    float M = max(c.r,max(c.g,c.b)),
          m = min(c.r,min(c.g,c.b)),
          d = M - m,
          l = (M+m)*0.5,
          s = d==0.0?0.0:d/(1.0-abs(2.0*l-1.0));
    float h=0.0;
    if(d>0.0){
      if(M==c.r) h = mod((c.g-c.b)/d + (c.g<c.b?6.0:0.0),6.0);
      else if(M==c.g) h = (c.b-c.r)/d +2.0;
      else h = (c.r-c.g)/d +4.0;
      h/=6.0;
    }
    return vec3(h,s,l);
  }
  
  float hue2rgb(float p, float q, float t){
    if(t<0.0) t+=1.0;
    if(t>1.0) t-=1.0;
    if(t<1.0/6.0) return p+(q-p)*6.0*t;
    if(t<1.0/2.0) return q;
    if(t<2.0/3.0) return p+(q-p)*(2.0/3.0-t)*6.0;
    return p;
  }
  
  vec3 hsl2rgb(vec3 c){
    float h=c.x, s=c.y, l=c.z;
    if(s==0.0) return vec3(l);
    float q = l<0.5?l*(1.0+s):l+s-l*s,
          p = 2.0*l - q;
    return vec3(
      hue2rgb(p,q,h+1.0/3.0),
      hue2rgb(p,q,h),
      hue2rgb(p,q,h-1.0/3.0)
    );
  }
  
  // Enhanced TouchDesigner Color composite operation
  vec3 touchDesignerColorComposite(vec3 base, vec3 overlay){
    vec3 hslBase = rgb2hsl(base);
    vec3 hslOverlay = rgb2hsl(overlay);
    
    // TouchDesigner Color composite: Use overlay hue/saturation, keep base luminance
    // But with enhanced blending for more natural results
    float blendedSaturation = mix(hslBase.y, hslOverlay.y, 0.8);
    return hsl2rgb(vec3(hslOverlay.x, blendedSaturation, hslBase.z));
  }
  
  // Gaussian blur function for post-processing
  vec3 gaussianBlur(sampler2D tex, vec2 uv, float blurAmount) {
    if(blurAmount <= 0.0) {
      return texture(tex, uv).rgb;
    }
    
    vec2 texelSize = vec2(1.0) / vec2(textureSize(tex, 0));
    vec3 result = vec3(0.0);
    float totalWeight = 0.0;
    
    // 9-tap Gaussian blur
    float weights[9];
    weights[0] = 0.0625; weights[1] = 0.125; weights[2] = 0.0625;
    weights[3] = 0.125;  weights[4] = 0.25;  weights[5] = 0.125;
    weights[6] = 0.0625; weights[7] = 0.125; weights[8] = 0.0625;
    
    vec2 offsets[9];
    offsets[0] = vec2(-1.0, -1.0); offsets[1] = vec2(0.0, -1.0); offsets[2] = vec2(1.0, -1.0);
    offsets[3] = vec2(-1.0,  0.0); offsets[4] = vec2(0.0,  0.0); offsets[5] = vec2(1.0,  0.0);
    offsets[6] = vec2(-1.0,  1.0); offsets[7] = vec2(0.0,  1.0); offsets[8] = vec2(1.0,  1.0);
    
    for(int i = 0; i < 9; i++) {
      vec2 sampleUV = uv + offsets[i] * texelSize * blurAmount;
      result += texture(tex, sampleUV).rgb * weights[i];
      totalWeight += weights[i];
    }
    
    return result / totalWeight;
  }
  
  // Enhanced noise-to-color mapping for better visual results
  vec3 enhancedNoiseColor(float n, vec3 videoCol){
    if(uMonochrome == 1) {
      return vec3(n);
    }
    
    if(uColorMode == 0) {
      // Default Perlin - TouchDesigner's original method
      return vec3(n, fract(n + 0.33), fract(n + 0.66));
    } else if(uColorMode == 1) {
      // Enhanced HSL mapping
      vec3 videoHSL = rgb2hsl(videoCol);
      
      // Use noise to modulate hue while keeping video's saturation/lightness influence
      float hueShift = n * uHueShift + videoHSL.x * (1.0 - uHueShift); // User-controllable hue blend
      float saturation = mix(0.7, 1.0, fract(n + 0.33)) * uColorSaturation; // User-controllable saturation
      float lightness = mix(0.3, 0.9, fract(n + 0.66)); // Variable lightness
      
      // Clamp saturation to prevent oversaturation
      saturation = clamp(saturation, 0.0, 1.0);
      
      return hsl2rgb(vec3(hueShift, saturation, lightness));
    } else {
      // Image Lookup mode - use noise to sample from color lookup texture
      // Create UV coordinates from noise for texture sampling
      vec2 lookupUV = vec2(n, fract(n + 0.5));
      
      // Sample the color lookup texture
      vec3 lookupColor = texture(uColorLookup, lookupUV).rgb;
      
      // Apply saturation adjustment to the lookup color
      if(uColorSaturation != 1.0) {
        vec3 lookupHSL = rgb2hsl(lookupColor);
        lookupHSL.y *= uColorSaturation;
        lookupHSL.y = clamp(lookupHSL.y, 0.0, 1.0);
        lookupColor = hsl2rgb(lookupHSL);
      }
      
      return lookupColor;
    }
  }

  void main(){
    // 1. Input - sample video texture
    vec3 videoCol = texture(uVideo, vUV).rgb;
    
    // 2. TouchDesigner Noise TOP behavior: Use video as coordinate map
    // The video RGB values become XYZ coordinates for noise sampling
    float scale = 1.0 / max(uPeriod, 0.0001);
    
    // TouchDesigner style: Video RGB directly drives noise coordinates
    // Mix spatial coordinates with video-driven coordinates
    vec3 spatialCoord = vec3(vUV * scale, uTime * 0.1);
    vec3 videoCoord = videoCol * scale * 2.0; // Scale video values to useful range
    
    // Blend spatial and video coordinates (this is the key TouchDesigner behavior)
    vec3 noiseCoord = mix(spatialCoord, videoCoord, uVideoInfluence) + vec3(0.0, 0.0, uTime * 0.1);
    
    // Generate base noise using video-driven coordinates
    float n = fbm(noiseCoord);
    
    // 3. Reshape - exactly like TouchDesigner Noise TOP
    n = sign(n) * pow(abs(n), uExponent);
    n = n * uAmplitude + uOffset;
    n = clamp(n, 0.0, 1.0);
    
    // 4. TouchDesigner workflow: Video -> Noise -> Composite
    // Generate enhanced noise color based on video content
    vec3 noiseCol = enhancedNoiseColor(n, videoCol);
    
    // 5. Apply TouchDesigner Composite operations
    vec3 outCol;
    if(uBlendMode == 0) {
      // Multiply - enhanced for better color preservation
      outCol = videoCol * mix(vec3(1.0), noiseCol, 0.8);
    } else if(uBlendMode == 1) {
      // Add - with better color balance
      outCol = videoCol + noiseCol * 0.4;
    } else if(uBlendMode == 2) {
      // Subtract - with better color balance
      outCol = videoCol - noiseCol * 0.4;
    } else {
      // TouchDesigner Color composite - the main attraction
      outCol = touchDesignerColorComposite(videoCol, noiseCol);
    }
    
    // Apply intensity (mix with original)
    outCol = mix(videoCol, outCol, uIntensity);
    
    // Apply Gaussian blur to the video input for dreamy effect
    if(uBlurAmount > 0.0) {
      vec3 blurredVideo = gaussianBlur(uVideo, vUV, uBlurAmount * 0.01);
      // Replace the original video with blurred version for softer noise interaction
      outCol = mix(outCol, blurredVideo, clamp(uBlurAmount * 0.1, 0.0, 0.8));
    }
    
    // Clamp final output
    outCol = clamp(outCol, 0.0, 1.0);
    
    // 6. Write output
    fragColor = vec4(outCol, 1.0);
  }`;

  // ———————————— GL helper fns ————————————
  function createShader(gl, type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(s));
    }
    return s;
  }
  function createProgram(gl, vsrc, fsrc){
    const v = createShader(gl, gl.VERTEX_SHADER,   vsrc);
    const f = createShader(gl, gl.FRAGMENT_SHADER, fsrc);
    const p = gl.createProgram();
    gl.attachShader(p,v);
    gl.attachShader(p,f);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(p));
    }
    return p;
  }
  </script>
</body>
</html>